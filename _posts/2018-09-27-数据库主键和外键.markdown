---
layout: post
title:  "数据库的主键和外键
"
date:   2018-10-17 10:36:02 +0800
categories: sql sequelize FK
---
# 数据库的主键和外键  

1.什么是主键 外键

|表名描述| 主键/外键|
| ----- | ----- |
| 学生表(学号，姓名，性别，班级) | 主键是学号 |
| 课程表（课程号, 课程名, 学分） | 主键是课程号 |
| 成绩表（学号, 课程号，得分） | 学号和课程号 组成一个主键  |

成绩表中学号不是 成绩表的主键， 但是 成绩表的外键， 同理课程号也是成绩表的外键。

**定义： 如果公共关键字在一个关系中是主关键字， 那么这个公共关键字被称为另一个关系的外键**
**以一个关系的外键作为主关键字的 表成为主表， 具有此外键的表称为从表**

2. 外键的作用
外键用于保持数据一致性， 完整性
主要目的是控制存储在外键表中的数据

3. 主键的设计原则

1） 主键应当是对用户没意义的

2） 主键是单列的， 以提高连接和筛选的效率
    - 复合健的使用通常出于两点考虑
        a) 主键应当具有意义——这为人为的破坏数据库提供了方便
        b) 在描述多对多关系的连接表中可以使用两个外部键作为主键——该表可能成为其他从表的主表，并成为从表的主键的一部分，使得之后的从表包含更多的列。

3） 永远不要更新主键

4） 主键不应该包含动态变化的数据(时间戳等)  

5） 主键应当由计算机自动生成

4. 数据库主键选取策略

    建立数据库的时候，需要为每一张表指定一个主键（一个表只能有一个主键，但是可以有多个候选索引）
    常见的主键选取方式有：
    1）自动增长型字段
        自动增长型主键会省略很多繁琐的工作，但在数据缓冲模式下，不能预先填写主键与外键的值
        Order(OrderID, OrderDate)   // 主键 OrderID 是自动增长型
        OrderDetail(OrderID, LineNum, ProductID, Price)
        如果要在 Order 表中插入一条记录， 在 OrderDetail 表中插入若干条记录， 为了能在 OrderDetail 表中插入正确的 OrderID 字段，必须要先更新 Order 表 以获得系统分配的 OrderID, 但是为了确保数据一致性， Order 表和 OrderDetail 表必须在事务保护下同时进行更新， 这显然是矛盾的。 
        除此之外，当需要在多个数据库之间进行数据复制，自动增长型字段可能造成主键冲突
    
    2）手动增长型字段
    
    3）使用 UniqueIDentifier SQL Server 提供的一个 UniqueIdentifier 数据类型(16字节)， 并提供一个生成函数 NEWID() 生成一个唯一的 UniqueIdentifier
    
    4） 使用 COMB 类型
        保留 UniqueIdentifier 的前 10  字节， 后 6 字节表示生成时间

--------------

1. 外键
    外键 （FK） 是用于建立或加强两个表数据之间的链接的一列或多列。
    通过将表中主键值的一列或多列添加到另一个表中， 可创建两个表之间的连接， 这个列就成为第二个表的外键。

    FK 约束的木就是为了控制存储在表中的数据， 同时可以控制对主键表中数据的修改。 

    例如： publisher 表中记录了发行商的信息， titles 表中记录了书名信息， 如果在pubslisher 表中删除一个出版商， 而这个出版商已经在 titles 表中记录数的信息的时候被使用了， 则这两个表关联性即将被破坏， 即 titles 表中该出版商的书籍因为与 publisher 表中的数据没有链接而变得孤立。 

    FK 约束可以防止这种情况发生， 如果主键表中的数据的更改使得与外键表中的数据链接失效， 那么这种更改不能实现。如果试图删除主键表中的行或者试图修改主键值， 而该主键值与另外一个表的 FK 约束值相关， 则这种操作不可实现。 若要成功的更改或者删除 FK 约束的行， 可以首先在从表中删除链接的数据行或者更改，改掉外键数据的指向。 

    **外键主要是用来控制数据库中的数据完整性的， 当对一个表的数据进行操作，和他有关联的一个表或者多个表的数据能够同时发生改变**

    例子：
    A(a,b) :a 为主键， b为外键 （来自于 B.b）
    B(b,c,d) :b 为主键

    A中 b的字段要么为空， 要么为 B 表中存在的值。 

    ------------

    在sequelize 可以通过 hasOne belongsTo hasMany 确立多个不同模型之间的关系。 

        
```javascript
    Model1.hasOne(Model2)
    Model2.belongsTo(Model1)
    // 通常会正反声明两遍 这样两个 model 下都会自动添加 set 对方数据的一系列的方法。
  
```


[jekyll-docs]: https://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
